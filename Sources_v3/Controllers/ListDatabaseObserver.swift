//
// Copyright © 2020 Stream.io Inc. All rights reserved.
//

import CoreData

/// This enum describes the changes of the given collections of items.
public enum ListChange<Item> {
    /// A new item was inserted on the given index path.
    case insert(_ item: Item, index: IndexPath)
    
    /// An item was moved from `fromIndex` to `toIndex`. Moving an item also automatically mean you should reload its UI.
    case move(_ item: Item, fromIndex: IndexPath, toIndex: IndexPath)
    
    /// An item was updated at the given `index`. An `update` change is also automatically generated by moving an item.
    case update(_ item: Item, index: IndexPath)
    
    /// An item was removed from the given `index`.
    case remove(_ item: Item, index: IndexPath)
}

extension ListChange: Equatable where Item: Equatable {}

/// Observes changes of the list of items specified using an `NSFetchRequest`in the provided `NSManagedObjectContext`.
///
/// `ListObserver` is just a wrapper around `NSFetchedResultsController` and `ChangeAggregator`. You can use both of
/// these elements separately, if it better fits your use case.
class ListDatabaseObserver<Item, DTO: NSManagedObject> {
    /// The current collection of items matching the provided fetch request. To receive granular updates to this collection,
    /// you can use the `onChange` callback.
    @Cached var items: [Item]
    
    /// Called with the aggregated changes after the internal `NSFetchResultsController` calls `controllerDidChangeContent`
    /// on its delegate.
    var onChange: (([ListChange<Item>]) -> Void)? {
        didSet {
            changeAggregator.onChange = { [unowned self] in
                self._items.reset()
                self.onChange?($0)
            }
        }
    }
    
    /// Acts like the `NSFetchedResultsController`'s delegate and aggregates the reported changes into easily consumable form.
    private(set) lazy var changeAggregator: ListChangeAggregator<DTO, Item> =
        ListChangeAggregator<DTO, Item>(itemCreator: self.itemCreator, frc: frc)
    
    /// Used for observing the changes in the DB.
    private(set) lazy var frc: NSFetchedResultsController<DTO> = self.fetchedResultsControllerType
        .init(
            fetchRequest: self.request,
            managedObjectContext: self.context,
            sectionNameKeyPath: nil,
            cacheName: nil
        )
    
    /// The `NSFetchedResultsController` subclass the observe uses to create its FRC. You can inject your custom subclass
    /// in the initializer if needed, i.e. when testing.
    let fetchedResultsControllerType: NSFetchedResultsController<DTO>.Type
    
    let itemCreator: (DTO) -> Item?
    let request: NSFetchRequest<DTO>
    let context: NSManagedObjectContext
    
    /// Creates a new `ListObserver`.
    ///
    /// Please note that no updates are reported until you call `startUpdating`.
    ///
    ///  - Important: ⚠️ Because the observer uses `NSFetchedResultsController` to observe the entity in the DB, it's required
    /// that the provided `fetchRequest` has at lease one `NSSortDescriptor` specified.
    ///
    /// - Parameters:
    ///   - context: The `NSManagedObjectContext` the observer observes.
    ///   - fetchRequest: The `NSFetchRequest` that specifies the elements of the list.
    ///   - itemCreator: A close the observe uses to convert DTO objects into Model objects.
    ///   - fetchedResultsControllerType: The `NSFetchedResultsController` subclass the observe uses to create its FRC. You can
    ///    inject your custom subclass if needed, i.e. when testing.
    init(
        context: NSManagedObjectContext,
        fetchRequest: NSFetchRequest<DTO>,
        itemCreator: @escaping (DTO) -> Item?,
        fetchedResultsControllerType: NSFetchedResultsController<DTO>.Type = NSFetchedResultsController<DTO>.self
    ) {
        self.context = context
        request = fetchRequest
        self.itemCreator = itemCreator
        self.fetchedResultsControllerType = fetchedResultsControllerType
        
        _items.computeValue = { [unowned self] in (self.frc.fetchedObjects ?? []).lazy.compactMap(self.itemCreator) }
    }
    
    /// Starts observing the changes in the database. The current items in the list are synchronously available in the
    /// `item` variable, after this function returns.
    ///
    /// - Throws: An error if the provided fetch request fails.
    func startObserving() throws {
        try frc.performFetch()
        frc.delegate = changeAggregator
        _items.reset()
        
        // This is a workaround for the situation when someone wants to observe only the `items` array without
        // listening to changes. We just need to make sure the `didSet` callback of `onChange` is executed at least once.
        if onChange == nil {
            onChange = nil
        }
    }
}

/// When this object is set as `NSFetchedResultsControllerDelegate`, it aggregates the callbacks from the fetched results
/// controller and forwards them in the way of `[Change<Item>]`. You can set the `onChange` callback to receive these updates.
class ListChangeAggregator<DTO: NSManagedObject, Item>: NSObject, NSFetchedResultsControllerDelegate {
    // TODO: Extend this to also provide `CollectionDifference` and `NSDiffableDataSourceSnapshot`
    
    /// Used for converting the `DTO`s provided by `FetchResultsController` to the resulting `Item`.
    let itemCreator: (DTO) -> Item?
    
    /// The `FetchResultsController` for which the current object serves as a delegate.
    let frc: NSFetchedResultsController<DTO>
    
    /// Called with the aggregated changes after `FetchResultsController` calls controllerDidChangeContent` on its delegate.
    var onChange: (([ListChange<Item>]) -> Void)?
    
    /// An array of changes in the current update. It gets reset every time `controllerWillChangeContent` is called, and
    /// published to the observer when `controllerDidChangeContent` is called.
    private var currentChanges: [ListChange<Item>] = []
    private var deletedItems: [NSManagedObjectID: Item] = [:]

    /// Creates a new `ChangeAggregator`.
    ///
    /// - Parameter itemCreator: Used for converting the `NSManagedObject`s provided by `FetchResultsController`
    /// to the resulting `Item`.
    init(itemCreator: @escaping (DTO) -> Item?, frc: NSFetchedResultsController<DTO>) {
        self.itemCreator = itemCreator
        self.frc = frc
        
        super.init()
        
        subscribeToNotifications()
    }
    
    deinit {
        unsubscribeFromNotifications()
    }

    // MARK: - NSFetchedResultsControllerDelegate
    
    // This should ideally be in the extensions but it's not possible to implement @objc methods in extensions of generic types.
    
    func controllerWillChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
        currentChanges = []
    }
    
    func controller(
        _ controller: NSFetchedResultsController<NSFetchRequestResult>,
        didChange anObject: Any,
        at indexPath: IndexPath?,
        for type: NSFetchedResultsChangeType,
        newIndexPath: IndexPath?
    ) {
        guard let dto = anObject as? DTO else {
            log.warning("Skipping the update from DB because the DTO can't be converted to the model object.")
            return
        }
        
        switch type {
        case .insert:
            guard let index = newIndexPath, let item = itemCreator(dto) else {
                log.warning("Skipping the update from DB because `newIndexPath` is missing for `.insert` change.")
                return
            }
            currentChanges.append(.insert(item, index: index))
            
        case .move:
            guard let fromIndex = indexPath, let toIndex = newIndexPath, let item = itemCreator(dto) else {
                log.warning("Skipping the update from DB because `indexPath` or `newIndexPath` are missing for `.move` change.")
                return
            }
            currentChanges.append(.move(item, fromIndex: fromIndex, toIndex: toIndex))
            
        case .update:
            guard let index = indexPath, let item = itemCreator(dto) else {
                log.warning("Skipping the update from DB because `indexPath` is missing for `.update` change.")
                return
            }
            currentChanges.append(.update(item, index: index))
            
        case .delete:
            guard let index = indexPath, let item = deletedItems.removeValue(forKey: dto.objectID) else {
                log.warning("Skipping the update from DB because `indexPath` is missing for `.delete` change.")
                return
            }
            currentChanges.append(.remove(item, index: index))
            
        default:
            break
        }
    }
    
    func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
        onChange?(currentChanges)
    }
    
    // MARK: - Private
    
    private func subscribeToNotifications() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(willSaveContext),
            name: .NSManagedObjectContextWillSave,
            object: nil
        )
    }
    
    private func unsubscribeFromNotifications() {
        NotificationCenter.default.removeObserver(self)
    }
    
    @objc private func willSaveContext(_ notification: Notification) {
        guard let context = notification.object as? NSManagedObjectContext else { return }
    
        // Get `DTO` ids the FRC is observing
        let fetchedDTOs = frc.fetchedObjects ?? []
        
        // Get `DTO` ids that are gonna be deleted
        let deletedDTOs = context
            .deletedObjects
            .compactMap { $0 as? DTO }
        
        // Get `DTO` ids that that no longer match the fetch request predicate
        let missmatchingDTOs = context
            .updatedObjects
            .compactMap { $0 as? DTO }
            .filter { frc.fetchRequest.predicate?.evaluate(with: $0) == false }
        
        // Perform `DTO -> Item` transformation in advance
        deletedItems.removeAll()
        (deletedDTOs + missmatchingDTOs).forEach { dtoToDelete in
            guard let trackedDTO = fetchedDTOs.first(where: { $0.objectID == dtoToDelete.objectID }) else { return }
            
            // Create item from DTO in advance before the actual deletion happen.
            // This is required because after the deletion, entity relations become invalid
            // and lossless `DTO -> Item` converion become impossible
            deletedItems[trackedDTO.objectID] = itemCreator(trackedDTO)
        }
    }
}

extension ListDatabaseObserver where DTO == Item {
    convenience init(
        context: NSManagedObjectContext,
        fetchRequest: NSFetchRequest<DTO>
    ) {
        self.init(
            context: context,
            fetchRequest: fetchRequest,
            itemCreator: { $0 }
        )
    }
}
